// Generated by CodiumAI




/*
Code Analysis

Main functionalities:
The Vector class represents a mathematical vector in two-dimensional space. It provides methods for performing common vector operations such as addition, subtraction, multiplication, and division, as well as calculating the magnitude and distance between vectors. It also includes static methods for calculating the distance between two vectors, interpolating between two vectors, finding the angle between a vector and a given angle, and rotating a point around a given origin.

Methods:
- add(v: Vector): adds the given vector to the current vector and returns a new vector representing the result
- sub(v: Vector): subtracts the given vector from the current vector and returns a new vector representing the result
- mult(n: number): multiplies the current vector by the given scalar value and returns a new vector representing the result
- div(n: number): divides the current vector by the given scalar value and returns a new vector representing the result
- mag(): calculates and returns the magnitude (length) of the current vector
- distanceTo(v: Vector): calculates and returns the distance between the current vector and the given vector
- static dist(v1: Vector, v2: Vector): calculates and returns the distance between two given vectors
- static lerp(start: Vector, end: Vector, amt: number): interpolates between two given vectors by the given amount and returns a new vector representing the result
- static angleVectorDifference(angle: number, vector: Vector): calculates and returns the angle between a given vector and a given angle
- static rotatePoint(point: Vector, origin: Vector, angle: number): rotates the given point around the given origin by the given angle and returns a new vector representing the result
- normalize(): normalizes the current vector (sets its magnitude to 1) and returns the current vector
- dot(v: Vector): calculates and returns the dot product of the current vector and the given vector
- copy(): creates and returns a new vector with the same x and y values as the current vector
- static sub(end: Vector, start: Vector): subtracts the start vector from the end vector and returns a new vector representing the result
- static add(start: Vector, mult: any): adds the given vector to the start vector and returns a new vector representing the result

Fields:
- x: the x-coordinate of the vector
- y: the y-coordinate of the vector
*/



import {describe, expect, test, it} from '@jest/globals';
import Vector from '../Vector';
describe('Vector_class', () => {
    // Tests creating a new Vector with default values.
    it("test_create_vector_default", () => {
        const vector = new Vector();
        expect(vector.x).toBe(0);
        expect(vector.y).toBe(0);
    });

    // Tests creating a new Vector with specified values.
    it("test_create_vector_specified", () => {
        const vector = new Vector(2, 3);
        expect(vector.x).toBe(2);
        expect(vector.y).toBe(3);
    });

    // Tests dividing a Vector by a scalar.
    it("test_divide_scalar", () => {
        const vector = new Vector(4, 6);
        const divided = vector.div(2);
        expect(divided.x).toBe(2);
        expect(divided.y).toBe(3);
        expect(vector.x).toBe(4);
        expect(vector.y).toBe(6);
    });

    // Tests adding two Vectors.
    it("test_add_vectors", () => {
        const vector1 = new Vector(2, 3);
        const vector2 = new Vector(4, 5);
        const added = vector1.add(vector2);
        expect(added.x).toBe(6);
        expect(added.y).toBe(8);
        expect(vector1.x).toBe(2);
        expect(vector1.y).toBe(3);
    });

    // Tests subtracting two Vectors.
    it("test_subtract_vectors", () => {
        const vector1 = new Vector(4, 6);
        const vector2 = new Vector(2, 3);
        const subtracted = vector1.sub(vector2);
        expect(subtracted.x).toBe(2);
        expect(subtracted.y).toBe(3);
    });

    // Tests multiplying a Vector by a scalar.
    it("test_multiply_scalar", () => {
        const vector = new Vector(2, 3);
        const multiplied = vector.mult(2);
        expect(multiplied.x).toBe(4);
        expect(multiplied.y).toBe(6);
    });

    // Tests calculating the magnitude of a Vector.
    it("test_magnitude", () => {
        // Happy path
        let v1 = new Vector(3, 4);
        expect(v1.mag()).toBe(5);

        // Edge case
        let v2 = new Vector(0, 0);
        expect(v2.mag()).toBe(0);
    });

    // Tests calculating the distance between two Vectors.
    it("test_distance_between_vectors", () => {
        const v1 = new Vector(0, 0);
        const v2 = new Vector(3, 4);
        expect(v1.distanceTo(v2)).toBe(5);
    });

    // Tests linearly interpolating between two Vectors using static method lerp.
    it("test_linear_interpolation", () => {
        const start = new Vector(0, 0);
        const end = new Vector(10, 10);
        const interpolated = Vector.lerp(start, end, 0.5);
        expect(interpolated.x).toBe(5);
        expect(interpolated.y).toBe(5);
    });

    // Tests rotating a point around an origin using static method rotatePoint.
    it("test_rotate_point", () => {
        const point = new Vector(1, 0);
        const origin = new Vector(0, 0);
        const rotated = Vector.rotatePoint(point, origin, Math.PI / 2);
        expect(rotated.x).toBeCloseTo(0);
        expect(rotated.y).toBeCloseTo(1);
    });

});
